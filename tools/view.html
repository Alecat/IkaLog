<html>
<head>
<style>
#graph {
  width: 100%;
  height: 100%;
}
.hidden {
  visibility: hidden;
}
</style>
</head>
<body>

<canvas id="graph" width="800" height="440"></canvas>
<canvas id="meter" class="hidden" width="720" height="402"></canvas>

<script>
function draw(data) {
  if (data == undefined) {
    return;
  }
  var events = data.events;
  if (events == undefined) {
    return;
  }

  if (data.offset_msec == undefined) {
    return;
  }
  var current_sec = parseInt(data.offset_msec / 1000);

  var canvas_meter = document.getElementById('meter');
  if (canvas_meter == undefined) {
    return;
  }
  var context_meter = canvas_meter.getContext('2d');

  draw_meter(context_meter, data);

  var canvas_graph = document.getElementById('graph');
  if (canvas_graph == undefined) {
    return;
  }
  var context_graph = canvas_graph.getContext('2d');
  var width = canvas_graph.width - 40;
  var height = canvas_graph.height - 19;
  context_graph.clearRect(20, 10, width, height);
  context_graph.drawImage(canvas_meter,
    0, 0, canvas_meter.width, canvas_meter.height,
    20, 10, width, height);
}

function draw_meter(context, data) {
  var events = data.events;
  var current_sec = parseInt(data.offset_msec / 1000);
  var width = context.canvas.width;
  var height = context.canvas.height;
  var x_scale = width / 360;
  var y_scale = height / 201;
  var mid_height = parseInt(height / 2) + (1 * y_scale);

  context.clearRect(0, 0, width, height);

  // Border
  context.rect(0, 0, width, height);
  context.stroke();

  // Time indicator
  context.beginPath();
  context.moveTo(current_sec * x_scale, 0);
  context.lineTo(current_sec * y_scale, height);
  context.stroke();

  var rule = data.rule;
  if (rule == 'yagura' || rule == 'hoko') {
    context.beginPath();
    context.moveTo(0, mid_height);
    context.lineTo(width, mid_height);
    context.stroke();

    var stroke = get_stroke_objective(events.objective, current_sec);
    if (stroke.length > 0) {
      context.beginPath();
      context.moveTo(0, mid_height);
      for (var i = 0; i < stroke.length; i++) {
        context.lineTo(stroke[i][0] * x_scale,
                       mid_height - stroke[i][1] * y_scale);
      }
      context.stroke();
    }
  } else if (rule == 'area') {
    var stroke = get_stroke_splatzone(events.splatzone, current_sec);
    for (var i = 1; i <= 2; i++) {
      if (stroke.length > 0) {
        context.beginPath();
        context.moveTo(0, height);
        for (var j = 0; j < stroke.length; j++) {
          context.lineTo(stroke[j][0] * x_scale,
                         stroke[j][i] * 2 * y_scale);
        }
        context.stroke();
      }
    }
  }

  inklings_strokes = get_stroke_inklings(events.inklings, current_sec);
  for (var i = 0; i < inklings_strokes.length; i++) {
    var stroke = inklings_strokes[i];
    for (var j = 0; j < stroke.length; j++) {
      if (stroke[j][0] == stroke[j][1]) {
        continue;
      }
      var y = 10 * i + 5;
      context.beginPath();
      context.moveTo(stroke[j][0] * x_scale, y * y_scale);
      context.lineTo(stroke[j][1] * x_scale, y * y_scale);
      context.stroke();
    }
  }
}

function get_stroke_objective(events, current_sec) {
  var stroke = [];
  if (events == undefined) {
    return stroke;
  }
  var last_sec = 0;
  var position = 0;
  for (var i = 0; i < events.length; i++) {
    var time = events[i][0];
    position = events[i][1];
    if (time > (last_sec * 1000)) {
      last_sec++;
      stroke.push([last_sec, position])
    }
  }
  if (last_sec != current_sec) {
    stroke.push([current_sec, position])
  }
  return stroke;
}

function get_stroke_splatzone(events, current_sec) {
  var stroke = [];
  if (events == undefined) {
    return stroke;
  }
  var last_sec = 0;
  var zone1 = 100;
  var zone2 = 100;
  for (var i = 0; i < events.length; i++) {
    var time = events[i][0];
    zone1 = events[i][1][0];
    zone2 = events[i][1][1];
    if (time > (last_sec * 1000)) {
      last_sec++;
      stroke.push([last_sec, zone1, zone2])
    }
  }
  if (last_sec != current_sec) {
    stroke.push([current_sec, zone1, zone2])
  }
  return stroke;
}

function get_stroke_inklings(events, current_sec) {
  strokes = [[[0,0]], [[0,0]], [[0,0]], [[0,0]],
             [[0,0]], [[0,0]], [[0,0]], [[0,0]]];
  if (events == undefined) {
    return strokes;
  }

  time_sec = 0;
  prev_inklings = [true, true, true, true, true, true, true, true];

  for (var i = 0; i < events.length; i++) {
    var time = events[i][0];
    time_sec = parseInt(time / 1000);
    var inklings = events[i][1][0].concat(events[i][1][1]);
    for (var j = 0; j < inklings.length; j++) {
      var stroke = strokes[j];
      if (prev_inklings[j]) {
        stroke[stroke.length - 1][1] = time_sec;
      } else if (inklings[j]) {
        stroke.push([time_sec, time_sec]);
      }
    }
    prev_inklings = inklings;
  }

  for (var j = 0; j < inklings.length; j++) {
    if (prev_inklings[j]) {
      var stroke = strokes[j];
      stroke[stroke.length - 1][1] = current_sec;
    }
  }

  return strokes;
}

function get_context() {
  var url = "http://localhost:8888/api/v1/engine/context/game";
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url, true);
  xhr.addEventListener("load", function(ev) {
    if (xhr.readyState == 4 && xhr.status == 200) {
      var context = JSON.parse(xhr.responseText);
      draw(context);
    }
  });
  xhr.addEventListener("error", function(ev) {
    // Do something.
  });
  xhr.send();
}

var interval = setInterval(get_context, 1000);
</script>
</body>
</html>
